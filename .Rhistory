plot_rt(rc = lbw_rc_rnk)
#TODO
# teen_wi <- read_csv("lbw_teen_wi.csv")
# teen_wi <- teen_wi %>% filter(!is.na(teen_births))
#
# teen_rc <- rank_cluster.bin(teen_wi$teen_births,teen_wi$teen_pop,row_names=teen_wi$county)
# teen_x10_rc <- rank_cluster.bin(teen_wi$teen_births*10,teen_wi$teen_pop*10,row_names=teen_wi$county)
View(binData)
binData <- binData %>% mutate(nbw=births-lbw) %>% filter(!is.na(lbw))
# Rank and Cluster Binomial Data CT Example
#setwd("/Users/cora/git_repos/ClusteredRanking/")
#devtools::use_data(binData)
#library(coda)
require(dplyr)
binData <- binData %>% mutate(nbw=births-lbw) %>% filter(!is.na(lbw))
install.packages("dplyr")
# Rank and Cluster Binomial Data CT Example
#setwd("/Users/cora/git_repos/ClusteredRanking/")
#devtools::use_data(binData)
#library(coda)
require(dplyr)
#setwd("/Users/cora/git_repos/ClusteredRanking/") #Need this?
binData <- read.csv("data/lbw_ct.csv")
binData <- binData %>% mutate(nbw=births-lbw) %>% filter(!is.na(lbw))
# Rank and Cluster Binomial Data CT Example
#setwd("/Users/cora/git_repos/ClusteredRanking/")
devtools::use_data(binData)
View(binData)
# Rank and Cluster Binomial Data CT Example
#setwd("/Users/cora/git_repos/ClusteredRanking/")
devtools::use_data(binData, overwrite = TRUE)
#setwd("/Users/cora/git_repos/ClusteredRanking/") #Need this?
binData <- read.csv("data/binData.rta")
#setwd("/Users/cora/git_repos/ClusteredRanking/") #Need this?
binData <- read.csv("data/binData.rda")
# Rank and Cluster Binomial Data CT Example
#setwd("/Users/cora/git_repos/ClusteredRanking/")
binData <- read.csv("data/lbw_ct.csv")
devtools::use_data(binData, overwrite = TRUE)
#setwd("/Users/cora/git_repos/ClusteredRanking/") #Need this?
binData <- load("data/binData.rda")
binData <- binData %>% mutate(nbw=births-lbw) %>% filter(!is.na(lbw))
#setwd("/Users/cora/git_repos/ClusteredRanking/") #Need this?
binData <- load("data/binData.rda")
binData
#setwd("/Users/cora/git_repos/ClusteredRanking/") #Need this?
binData <- data("data/binData.rda")
#setwd("/Users/cora/git_repos/ClusteredRanking/") #Need this?
load(file = "binData.rda")
# Rank and Cluster Binomial Data CT Example
#setwd("/Users/cora/git_repos/ClusteredRanking/")
binData <- read.csv("data/lbw_ct.csv")
devtools::use_data(binData, overwrite = TRUE)
#setwd("/Users/cora/git_repos/ClusteredRanking/") #Need this?
load(file = "binData.rda")
#setwd("/Users/cora/git_repos/ClusteredRanking/") #Need this?
load(file = "data/binData.rda")
binData <- binData %>% mutate(nbw=births-lbw) %>% filter(!is.na(lbw))
lbw_rc <- rank_cluster.bin(binData$lbw,binData$births,row_names=binData$county)
lbw_rc2 <- rank_cluster.bin(binData$lbw,binData$births,row_names=binData$county,weighted=FALSE)
lbw_x10_rc <- rank_cluster.bin(binData$lbw*10,binData$births*10,row_names=binData$county)
lbw_x100_rc <- rank_cluster.bin(binData$lbw*100,binData$births*100,row_names=binData$county)
lbw_rc_rnk <- rank_cluster.bin(binData$lbw,binData$births,row_names=binData$county,scale=rank)
lbw_rc_rnk2 <- rank_cluster.bin(binData$lbw,binData$births,row_names=binData$county,scale=rank,weighted=FALSE)
lbw_x10_rc <- rank_cluster.bin(binData$lbw*10,binData$births*10,row_names=binData$county)
plot_rt(rc = lbw_rc_rnk)
dim(binData)
length(binData)
is.NA(binData)
is.na(binData)
devtools::test()
devtools::test(test_bin.R)
devtools::test("test_bin.R")
devtools::test("test_bin.R")
devtools::test()
devtools::test()
usethis::use_test("test_norm.r")
install.packages("usethis")
usethis::use_test("test_norm.r")
devtools::test()
devtools::test()
install.packages("tidyverse")
devtools::test()
devtools::test()
devtools::test()
length(binData)
setwd("/Users/cora/git_repos/ClusteredRanking/")
load(file = "data/binData.rda")
test_that("imports data", {
expect_equal(length(binData), 5)
expect_equal(nrow(binData), 8)
})
length(binData)
length(binData)
devtools::test()
devtools::test()
lbw_rc_rnk
lbw_rc_rnk$theta
devtools::test()
devtools::test()
devtools::test()
# Rank and Cluster Pisson CT Example Data
library(tidyverse)
library(coda)
library(reshape2)
library(clue)
library(Hmisc)
library(RColorBrewer)
setwd("/Users/cora/git_repos/RankingMethods")
poisData <- read_csv("data/lbw_ct.csv")
poisData <- poisData %>% mutate(nbw=births-lbw) %>% filter(!is.na(lbw))
lbw_rc <- rank_cluster.pois(poisData$lbw,poisData$births,row_names=poisData$county)
lbw_rc2 <- rank_cluster.pois(poisData$lbw,poisData$births,row_names=poisData$county,weighted=FALSE)
lbw_x10_rc <- rank_cluster.pois(poisData$lbw*10,poisData$births*10,row_names=poisData$county)
lbw_x100_rc <- rank_cluster.pois(poisData$lbw*100,poisData$births*100,row_names=poisData$county)
lbw_rc_rnk <- rank_cluster.pois(poisData$lbw,poisData$births,row_names=poisData$county,scale=rank)
lbw_rc_rnk2 <- rank_cluster.pois(poisData$lbw,poisData$births,row_names=poisData$county,scale=rank,weighted=FALSE)
lbw_x10_rc <- rank_cluster.pois(poisData$lbw*10,poisData$births*10,row_names=poisData$county)
plot_rt(rc = lbw_rc_rnk)
#TODO
# teen_wi <- read_csv("lbw_teen_wi.csv")
# teen_wi <- teen_wi %>% filter(!is.na(teen_births))
#
# teen_rc <- rank_cluster.pois(teen_wi$teen_births,teen_wi$teen_pop,row_names=teen_wi$county)
# teen_x10_rc <- rank_cluster.pois(teen_wi$teen_births*10,teen_wi$teen_pop*10,row_names=teen_wi$county)
#Cluster Ranking Poisson functions
#note: replaced theta with lambda
library(tidyverse)
library(coda)
library(reshape2)
library(clue)
library(Hmisc)
library(RColorBrewer)
npmle.pois <- function(y,n,k=NULL,n.iter=1000,row_names=NULL) {
if (is.null(k)) {
lambda<-sort(y/n) #sorted probabilities
k<-length(lambda) #number of units to rank
} else {
lambda <- seq(min(y/n),max(y/n),length=k)
}
p_lambda <- rep(1/k,k) #evenly spaced probabilities between 0 and 1 for groups?
E_z <- matrix(NA,length(y),k)
for (j in 1:n.iter) {
for (i in 1:k) {
#The R function dpois(x, lambda) calculates the probability that there are x events in an interval,
#where the argument "lambda" is the average number of events per interval.
#TODO check this
E_z[,i] <- log(p_lambda[i])+dpois(y/n, lambda[i],log=TRUE) #TODO E_z is log(pr associated with group) + log(quantile)?
}
E_z <- t(apply(E_z,1,function(x) exp(x-max(x))/sum(exp(x-max(x))))) #E_z will be
p_lambda <- apply(E_z,2,mean)
lambda <- y%*%E_z/n%*%E_z #does this reassign lambda? Do we want this?
}
ord<-order(lambda)
lambda<-c(lambda[ord])
p_lambda<-p_lambda[ord]
p_lambda <- tapply(p_lambda,cumsum(!duplicated(round(lambda,8))),sum)
lambda <- lambda[!duplicated(round(lambda,8))]
E_z <- matrix(NA,length(y),length(lambda))
for (i in 1:length(lambda)) {
E_z[,i] <- log(p_lambda[i])+dpois(y/n,lambda[i],log=TRUE)
}
E_z <- t(apply(E_z,1,function(x) exp(x-max(x))/sum(exp(x-max(x)))))
rownames(E_z)<-row_names
colnames(E_z)<-signif(lambda,3)
return(list(lambda=lambda, p_lambda=p_lambda, post_lambda=E_z))
}
rank_cluster.pois <- function(y,n,k=NULL,scale=identity,weighted=TRUE,n.iter=1000,n.samp=10000,row_names=NULL) {
N <- length(y)
npmle_res <- npmle.pois(y,n,k,n.iter,row_names)
smp <- apply(npmle_res$post_lambda,1,
function(x,lambda,n.samp)
sample(lambda,n.samp,replace=TRUE,prob=x),
lambda=scale(npmle_res$lambda),n.samp=n.samp)
smp <- t(smp)
smp.ord <- apply(smp,2,sort)
if (weighted) wgt <- 1/pmax(.Machine$double.eps,apply(smp,1,var)) else wgt <- rep(1,N)
loss <- matrix(NA,N,N)
for (i in 1:N) {
for (j in 1:N) {
loss[i,j] <- wgt[i] * mean((smp[i,]-smp.ord[j,])^2)
}
}
rnk <- as.numeric(solve_LSAP(loss))
grp <- match(apply(smp.ord,1,getmode),scale(npmle_res$lambda))[rnk]
grp <- factor(grp)
p_grp <- npmle_res$post_lambda[cbind(1:N,as.numeric(grp))]
levels(grp) <- signif(npmle_res$lambda,3)
ord <- order(rnk)
CI <- poisconf(y,n)
ranked_table <- data_frame(name=row_names,rank=rnk,group=factor(grp),
y=y,n=n,p=y/n,
p_LCL=CI[,2],p_UCL=CI[,3],
pm=c(npmle_res$post_lambda%*%npmle_res$lambda),
p_grp=p_grp)
ranked_table <- ranked_table[ord,]
ranked_table$name <- factor(ranked_table$name,levels=ranked_table$name,ordered=TRUE)
posterior <- npmle_res$post_lambda[ord,]
return(list(ranked_table=ranked_table,posterior=posterior,lambda=npmle_res$lambda,pr_lambda=npmle_res$p_lambda))
}
getmode <- function(v) {
uniqv <- unique(v)
uniqv[which.max(tabulate(match(v, uniqv)))]
}
plot_rt <- function(rc,xlab="Proportion") {
post_df <- melt(rc$posterior)
post_df$group <- rc$ranked_table$group[match(post_df$Var1,rc$ranked_table$name)]
post_df$p_grp <- rc$ranked_table$p_grp[match(post_df$Var1,rc$ranked_table$name)]
return(ggplot(rc$ranked_table,aes(y=name,x=p,color=group,alpha=p_grp))+
geom_point(pch=3)+
geom_point(aes(x=pm),pch=4)+
geom_point(data=post_df,aes(y=Var1,x=as.numeric(Var2),color=group,size=value,alpha=value))+
geom_errorbarh(aes(xmin=p_LCL,xmax=p_UCL),height=0)+
scale_y_discrete("",limits=rev(levels(rc$ranked_table$name)))+
scale_x_continuous(xlab,breaks=rc$lambda[!duplicated(round(rc$lambda,2))],
labels=round(rc$lambda[!duplicated(round(rc$lambda,2))],3),minor_breaks=rc$lambda)+
scale_color_manual(values=rep(brewer.pal(8,"Dark2"),1+floor(length(levels(rc$ranked_table$group))/8)))+
scale_size_area(max_size=5)+
scale_alpha(limits=c(0,1),range=c(0,1))+
theme_bw()+
guides(color=FALSE,size=FALSE,alpha=FALSE))
}
# Rank and Cluster Pisson CT Example Data
library(tidyverse)
library(coda)
library(reshape2)
library(clue)
library(Hmisc)
library(RColorBrewer)
setwd("/Users/cora/git_repos/RankingMethods")
poisData <- read_csv("data/lbw_ct.csv")
poisData <- poisData %>% mutate(nbw=births-lbw) %>% filter(!is.na(lbw))
lbw_rc <- rank_cluster.pois(poisData$lbw,poisData$births,row_names=poisData$county)
lbw_rc2 <- rank_cluster.pois(poisData$lbw,poisData$births,row_names=poisData$county,weighted=FALSE)
lbw_x10_rc <- rank_cluster.pois(poisData$lbw*10,poisData$births*10,row_names=poisData$county)
lbw_x100_rc <- rank_cluster.pois(poisData$lbw*100,poisData$births*100,row_names=poisData$county)
lbw_rc_rnk <- rank_cluster.pois(poisData$lbw,poisData$births,row_names=poisData$county,scale=rank)
lbw_rc_rnk2 <- rank_cluster.pois(poisData$lbw,poisData$births,row_names=poisData$county,scale=rank,weighted=FALSE)
lbw_x10_rc <- rank_cluster.pois(poisData$lbw*10,poisData$births*10,row_names=poisData$county)
plot_rt(rc = lbw_rc_rnk)
#TODO
# teen_wi <- read_csv("lbw_teen_wi.csv")
# teen_wi <- teen_wi %>% filter(!is.na(teen_births))
#
# teen_rc <- rank_cluster.pois(teen_wi$teen_births,teen_wi$teen_pop,row_names=teen_wi$county)
# teen_x10_rc <- rank_cluster.pois(teen_wi$teen_births*10,teen_wi$teen_pop*10,row_names=teen_wi$county)
library(tidyverse)
library(coda)
#library(coda)
library(reshape2)
library(clue)
library(Hmisc)
library(RColorBrewer)
npmle.pois <- function(y,n,k=NULL,n.iter=1000,row_names=NULL) {
if (is.null(k)) {
lambda<-sort(y/n) #sorted probabilities
k<-length(lambda) #number of units to rank
} else {
lambda <- seq(min(y/n),max(y/n),length=k)
}
p_lambda <- rep(1/k,k) #evenly spaced probabilities between 0 and 1 for groups?
E_z <- matrix(NA,length(y),k)
for (j in 1:n.iter) {
for (i in 1:k) {
#The R function dpois(x, lambda) calculates the probability that there are x events in an interval,
#where the argument "lambda" is the average number of events per interval.
#TODO check this
E_z[,i] <- log(p_lambda[i])+dpois(y/n, lambda[i],log=TRUE) #TODO E_z is log(pr associated with group) + log(quantile)?
}
E_z <- t(apply(E_z,1,function(x) exp(x-max(x))/sum(exp(x-max(x))))) #E_z will be
p_lambda <- apply(E_z,2,mean)
lambda <- y%*%E_z/n%*%E_z #does this reassign lambda? Do we want this?
}
ord<-order(lambda)
lambda<-c(lambda[ord])
p_lambda<-p_lambda[ord]
p_lambda <- tapply(p_lambda,cumsum(!duplicated(round(lambda,8))),sum)
lambda <- lambda[!duplicated(round(lambda,8))]
E_z <- matrix(NA,length(y),length(lambda))
for (i in 1:length(lambda)) {
E_z[,i] <- log(p_lambda[i])+dpois(y/n,lambda[i],log=TRUE)
}
E_z <- t(apply(E_z,1,function(x) exp(x-max(x))/sum(exp(x-max(x)))))
rownames(E_z)<-row_names
colnames(E_z)<-signif(lambda,3)
return(list(lambda=lambda, p_lambda=p_lambda, post_lambda=E_z))
}
rank_cluster.pois <- function(y,n,k=NULL,scale=identity,weighted=TRUE,n.iter=1000,n.samp=10000,row_names=NULL) {
N <- length(y)
npmle_res <- npmle.pois(y,n,k,n.iter,row_names)
smp <- apply(npmle_res$post_lambda,1,
function(x,lambda,n.samp)
sample(lambda,n.samp,replace=TRUE,prob=x),
lambda=scale(npmle_res$lambda),n.samp=n.samp)
smp <- t(smp)
smp.ord <- apply(smp,2,sort)
if (weighted) wgt <- 1/pmax(.Machine$double.eps,apply(smp,1,var)) else wgt <- rep(1,N)
loss <- matrix(NA,N,N)
for (i in 1:N) {
for (j in 1:N) {
loss[i,j] <- wgt[i] * mean((smp[i,]-smp.ord[j,])^2)
}
}
rnk <- as.numeric(solve_LSAP(loss))
grp <- match(apply(smp.ord,1,getmode),scale(npmle_res$lambda))[rnk]
grp <- factor(grp)
p_grp <- npmle_res$post_lambda[cbind(1:N,as.numeric(grp))]
levels(grp) <- signif(npmle_res$lambda,3)
ord <- order(rnk)
CI <- poisconf(y,n)
ranked_table <- data_frame(name=row_names,rank=rnk,group=factor(grp),
y=y,n=n,p=y/n,
p_LCL=CI[,2],p_UCL=CI[,3],
pm=c(npmle_res$post_lambda%*%npmle_res$lambda),
p_grp=p_grp)
ranked_table <- ranked_table[ord,]
ranked_table$name <- factor(ranked_table$name,levels=ranked_table$name,ordered=TRUE)
posterior <- npmle_res$post_lambda[ord,]
return(list(ranked_table=ranked_table,posterior=posterior,lambda=npmle_res$lambda,pr_lambda=npmle_res$p_lambda))
}
getmode <- function(v) {
uniqv <- unique(v)
uniqv[which.max(tabulate(match(v, uniqv)))]
}
plot_rt <- function(rc,xlab="Proportion") {
post_df <- melt(rc$posterior)
post_df$group <- rc$ranked_table$group[match(post_df$Var1,rc$ranked_table$name)]
post_df$p_grp <- rc$ranked_table$p_grp[match(post_df$Var1,rc$ranked_table$name)]
return(ggplot(rc$ranked_table,aes(y=name,x=p,color=group,alpha=p_grp))+
geom_point(pch=3)+
geom_point(aes(x=pm),pch=4)+
geom_point(data=post_df,aes(y=Var1,x=as.numeric(Var2),color=group,size=value,alpha=value))+
geom_errorbarh(aes(xmin=p_LCL,xmax=p_UCL),height=0)+
scale_y_discrete("",limits=rev(levels(rc$ranked_table$name)))+
scale_x_continuous(xlab,breaks=rc$lambda[!duplicated(round(rc$lambda,2))],
labels=round(rc$lambda[!duplicated(round(rc$lambda,2))],3),minor_breaks=rc$lambda)+
scale_color_manual(values=rep(brewer.pal(8,"Dark2"),1+floor(length(levels(rc$ranked_table$group))/8)))+
scale_size_area(max_size=5)+
scale_alpha(limits=c(0,1),range=c(0,1))+
theme_bw()+
guides(color=FALSE,size=FALSE,alpha=FALSE))
}
setwd("/Users/cora/git_repos/RankingMethods")
poisData <- read_csv("data/lbw_ct.csv")
poisData <- poisData %>% mutate(nbw=births-lbw) %>% filter(!is.na(lbw))
lbw_rc <- rank_cluster.pois(poisData$lbw,poisData$births,row_names=poisData$county)
warnings()
#functions for grouped ranking
#use this instead? devtools::use_package("dplyr") # Defaults to imports
library(ggplot2)
#library(coda) #what does coda do? (which command)
library(reshape2)
library(clue)
library(Hmisc)
library(RColorBrewer)
npmle.pois <- function(y,n,k=NULL,n.iter=1000,row_names=NULL) {
if (is.null(k)) {
lambda<-sort(y/n) #sorted probabilities
k<-length(lambda) #number of units to rank
} else {
lambda <- seq(min(y/n),max(y/n),length=k)
}
p_lambda <- rep(1/k,k) #evenly spaced probabilities between 0 and 1 for groups?
E_z <- matrix(NA,length(y),k)
for (j in 1:n.iter) {
for (i in 1:k) {
#The R function dpois(x, lambda) calculates the probability that there are x events in an interval,
#where the argument "lambda" is the average number of events per interval.
#TODO check this In dpois(y/n, lambda[i], log = TRUE) : non-integer x = 0.076169
#this is the mixture distribution, right?
E_z[,i] <- log(p_lambda[i])+dpois(y, lambda[i],log=TRUE)
}
E_z <- t(apply(E_z,1,function(x) exp(x-max(x))/sum(exp(x-max(x))))) #E_z will be
p_lambda <- apply(E_z,2,mean)
lambda <- y%*%E_z/n%*%E_z #does this reassign lambda? Do we want this?
}
ord<-order(lambda)
lambda<-c(lambda[ord])
p_lambda<-p_lambda[ord]
p_lambda <- tapply(p_lambda,cumsum(!duplicated(round(lambda,8))),sum)
lambda <- lambda[!duplicated(round(lambda,8))]
E_z <- matrix(NA,length(y),length(lambda))
for (i in 1:length(lambda)) {
E_z[,i] <- log(p_lambda[i])+dpois(y/n,lambda[i],log=TRUE)
}
E_z <- t(apply(E_z,1,function(x) exp(x-max(x))/sum(exp(x-max(x)))))
rownames(E_z)<-row_names
colnames(E_z)<-signif(lambda,3)
return(list(lambda=lambda, p_lambda=p_lambda, post_lambda=E_z))
}
rank_cluster.pois <- function(y,n,k=NULL,scale=identity,weighted=TRUE,n.iter=1000,n.samp=10000,row_names=NULL) {
N <- length(y)
npmle_res <- npmle.pois(y,n,k,n.iter,row_names)
smp <- apply(npmle_res$post_lambda,1,
function(x,lambda,n.samp)
sample(lambda,n.samp,replace=TRUE,prob=x),
lambda=scale(npmle_res$lambda),n.samp=n.samp)
smp <- t(smp)
smp.ord <- apply(smp,2,sort)
if (weighted) wgt <- 1/pmax(.Machine$double.eps,apply(smp,1,var)) else wgt <- rep(1,N)
loss <- matrix(NA,N,N)
for (i in 1:N) {
for (j in 1:N) {
loss[i,j] <- wgt[i] * mean((smp[i,]-smp.ord[j,])^2)
}
}
rnk <- as.numeric(solve_LSAP(loss))
grp <- match(apply(smp.ord,1,getmode),scale(npmle_res$lambda))[rnk]
grp <- factor(grp)
p_grp <- npmle_res$post_lambda[cbind(1:N,as.numeric(grp))]
levels(grp) <- signif(npmle_res$lambda,3)
ord <- order(rnk)
CI <- poisconf(y,n)
ranked_table <- data_frame(name=row_names,rank=rnk,group=factor(grp),
y=y,n=n,p=y/n,
p_LCL=CI[,2],p_UCL=CI[,3],
pm=c(npmle_res$post_lambda%*%npmle_res$lambda),
p_grp=p_grp)
ranked_table <- ranked_table[ord,]
ranked_table$name <- factor(ranked_table$name,levels=ranked_table$name,ordered=TRUE)
posterior <- npmle_res$post_lambda[ord,]
return(list(ranked_table=ranked_table,posterior=posterior,lambda=npmle_res$lambda,pr_lambda=npmle_res$p_lambda))
}
getmode <- function(v) {
uniqv <- unique(v)
uniqv[which.max(tabulate(match(v, uniqv)))]
}
plot_rt <- function(rc,xlab="Proportion") {
post_df <- melt(rc$posterior)
post_df$group <- rc$ranked_table$group[match(post_df$Var1,rc$ranked_table$name)]
post_df$p_grp <- rc$ranked_table$p_grp[match(post_df$Var1,rc$ranked_table$name)]
return(ggplot(rc$ranked_table,aes(y=name,x=p,color=group,alpha=p_grp))+
geom_point(pch=3)+
geom_point(aes(x=pm),pch=4)+
geom_point(data=post_df,aes(y=Var1,x=as.numeric(Var2),color=group,size=value,alpha=value))+
geom_errorbarh(aes(xmin=p_LCL,xmax=p_UCL),height=0)+
scale_y_discrete("",limits=rev(levels(rc$ranked_table$name)))+
scale_x_continuous(xlab,breaks=rc$lambda[!duplicated(round(rc$lambda,2))],
labels=round(rc$lambda[!duplicated(round(rc$lambda,2))],3),minor_breaks=rc$lambda)+
scale_color_manual(values=rep(brewer.pal(8,"Dark2"),1+floor(length(levels(rc$ranked_table$group))/8)))+
scale_size_area(max_size=5)+
scale_alpha(limits=c(0,1),range=c(0,1))+
theme_bw()+
guides(color=FALSE,size=FALSE,alpha=FALSE))
}
poisData <- read_csv("data/lbw_ct.csv")
poisData <- poisData %>% mutate(nbw=births-lbw) %>% filter(!is.na(lbw))
lbw_rc <- rank_cluster.pois(poisData$lbw,poisData$births,row_names=poisData$county)
View(poisData)
poisData$county
poisData <- poisData %>% mutate(nbw=births-lbw) %>% filter(!is.na(lbw))
lbw_rc <- rank_cluster.pois(poisData$lbw,poisData$births,row_names=poisData$county)
lambda <- seq(min(poisData$y/poisData$n),max(poisData$y/poisData$n),length=8)
lambda <- seq(min(poisData$lbw/poisData$births),max(poisData$lbw/poisData$births),length=8)
p_lambda <- rep(1/8,8)
E_z <- matrix(NA,length(poisData$births),8)
for (j in 1:1000) {
for (i in 1:8) {
#The R function dpois(x, lambda) calculates the probability that there are x events in an interval,
#where the argument "lambda" is the average number of events per interval.
#TODO check this In dpois(y/n, lambda[i], log = TRUE) : non-integer x = 0.076169
#this is the mixture distribution, right?
E_z[,i] <- log(p_lambda[i])+dpois(poisData$births, lambda[i],log=TRUE)
}
E_z <- t(apply(E_z,1,function(x) exp(x-max(x))/sum(exp(x-max(x))))) #E_z will be
p_lambda <- apply(E_z,2,mean)
lambda <- poisData$lbw%*%E_z/n%*%E_z #does this reassign lambda? Do we want this?
}
for (j in 1:1000) {
for (i in 1:8) {
#The R function dpois(x, lambda) calculates the probability that there are x events in an interval,
#where the argument "lambda" is the average number of events per interval.
#TODO check this In dpois(y/n, lambda[i], log = TRUE) : non-integer x = 0.076169
#this is the mixture distribution, right?
E_z[,i] <- log(p_lambda[i])+dpois(poisData$births, lambda[i],log=TRUE)
}
E_z <- t(apply(E_z,1,function(x) exp(x-max(x))/sum(exp(x-max(x))))) #E_z will be
p_lambda <- apply(E_z,2,mean)
lambda <- poisData$lbw%*%E_z/poisData$births%*%E_z #does this reassign lambda? Do we want this?
}
ord<-order(lambda)
lambda<-c(lambda[ord])
p_lambda<-p_lambda[ord]
p_lambda <- tapply(p_lambda,cumsum(!duplicated(round(lambda,8))),sum)
lambda <- lambda[!duplicated(round(lambda,8))]
E_z <- matrix(NA,length(poisData$lbw),length(lambda))
for (i in 1:length(lambda)) {
E_z[,i] <- log(p_lambda[i])+dpois(poisData$lbw/poisData$births,lambda[i],log=TRUE)
}
E_z <- t(apply(E_z,1,function(x) exp(x-max(x))/sum(exp(x-max(x)))))
rownames(E_z)<-row_names
rn <- poisData$county
rownames(E_z)<-rn
dim(E_z)
length(rn)
rownames(t(E_z)) <- rn
rownames(t(E_z)) <- rn
t(E_z)
E_z <- matrix(NA,8,length(lambda))
for (i in 1:length(lambda)) {
E_z[,i] <- log(p_lambda[i])+dpois(poisData$lbw,lambda[i],log=TRUE)
}
E_z
E_z <- t(apply(E_z,1,function(x) exp(x-max(x))/sum(exp(x-max(x)))))
log(p_lambda[i])+dpois(poisData$lbw,lambda[i],log=TRUE)
dpois(poisData$lbw,lambda[i],log=TRUE)
log(p_lambda[i])
p_lambda
ord
lambda<-c(lambda[ord])
lambda
View(binData)
